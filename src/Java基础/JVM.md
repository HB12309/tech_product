## 垃圾回收算法
标记清除
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。
在标记阶段⾸先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引⽤
的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。
复制算法
从根集合节点进⾏扫描，标记出所有的存活对象，并将这些存活的对象复制到⼀块⼉新的内存（图中下
边的那⼀块⼉内存）上去，之后将原来的那⼀块⼉内存（图中上边的那⼀块⼉内存）全部回收掉
标记整理
复制算法的⾼效性是建⽴在存活对象少、垃圾对象多的前提下的。
这种情况在新⽣代经常发⽣，但是在⽼年代更常⻅的情况是⼤部分对象都是存活对象。如果依然使⽤复
制算法，由于存活的对象较多，复制的成本也将很⾼。
分代收集算法
分代收集算法就是⽬前虚拟机使⽤的回收算法，它解决了标记整理不适⽤于⽼年代的问题，将内存分为
各个年代。⼀般情况下将堆区划分为⽼年代（Tenured Generation）和新⽣代（Young Generation），
在堆区之外还有⼀个代就是永久代（Permanet Generation）。
在不同年代使⽤不同的算法，从⽽使⽤最合适的算法，新⽣代存活率低，可以使⽤复制算法。⽽⽼年代
对象存活率高，没有额外空间对它进⾏分配担保，所以只能使⽤标记清除或者标记整理算法。

## CMS垃圾回收器和G1收集器的特点，和收集过程
CMS收集器是⼀种以获取最短回收停顿时间为⽬标的收集器。基于“标记-清除”算法实现，它的运作过程如下：
初始标记
并发标记
重新标记
并发清除

初始标记、重新标记这两个步骤仍然需要“stop the world”
初始标记仅仅只是标记⼀下GC Roots能直接关联到的对象，速度很快。
并发标记阶段就是进⾏GC Roots Tracing。
重新标记阶段则是为了修正并发标记期间因⽤户程序继续运作⽽导致标记产⽣表动的那⼀部分对象的标记记录，这个
阶段的停顿时间⼀般会⽐初始标记阶段稍⻓点，但远⽐并发标记的时间短。 

CMS是⼀款优秀的收集器，主要优点：并发收集、低停顿。
缺点：
CMS收集器对CPU资源⾮常敏感。在并发阶段，它虽然不会导致⽤户线程停顿，但是会因为占⽤了
⼀部分线程⽽导致应⽤程序变慢，总吞吐量会降低。
CMS收集器⽆法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败⽽导
致Full GC产⽣。
浮动垃圾：由于CMS并发清理阶段⽤户线程还在运⾏着，伴随着程序运⾏⾃然就会有新的垃圾不断产
⽣，这部分垃圾出现的标记过程之后，CMS⽆法在当次收集中处理掉它们，只好留待下⼀次GC中再清
理。这些垃圾就是“浮动垃圾”。
CMS是⼀款“标记--清除”算法实现的收集器，容易出现⼤量空间碎⽚。当空间碎⽚过多，将会给⼤
对象分配带来很⼤的麻烦，往往会出现⽼年代还有很⼤空间剩余，但是⽆法找到⾜够⼤的连续空间
来分配当前对象，不得不提前触发⼀次Full GC。

G1是⼀款⾯向服务端应⽤的垃圾收集器。
G1具备如下特点：
并⾏于并发：G1能充分利⽤CPU、多核环境下的硬件优势，使⽤多个CPU（CPU或者CPU核⼼）
来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执⾏的GC动作，G1收集
器仍然可以通过并发的⽅式让java程序继续执⾏。
分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概
念。它能够采⽤不同的⽅式去处理新创建的对象和已经存活了⼀段时间，熬过多次GC的旧对象以获
取更好的收集效果。
空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；
从局部上来看是基于“复制”算法实现的。
可预测的停顿：这是G1相对于CMS的另⼀个⼤优势，降低停顿时间是G1和ＣＭＳ共同的关注点，
但Ｇ１除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使⽤者明确指定在⼀个⻓度为M
毫秒的时间⽚段内，
G1运作步骤：
1、初始标记；2、并发标记；3、最终标记；4、筛选回收

## 如何判定⼀个对象是否应该回收
为了解决循环引⽤的问题，java中采取了正向可达的⽅式，主要是通过 Roots 对象作为起点进⾏搜索，
搜索⾛过的路径称为“引⽤链”，当⼀个对象到 Roots 没有任何的引⽤链相连时时，证明此对象不可
⽤，当然被判定为不可达的对象不⼀定就会成为可回收对象。
被判定为不可达的对象要成为可回收对象必须⾄少经历两次标记过程，如果在这两次标记过程中仍然没
有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了，能否被回收其实主要还是要
看 finalize() ⽅法有没有与引⽤链上的对象关联，如果在 finalize() ⽅法中有关联则⾃救成功，
对象不可被回收，反之如果没有关联则成功被⼆次标记成功，就可以称为要被回收的垃圾了。

## JVM创建对象的过程 new
常量池中定位类的符号引⽤
↓
检查符号引⽤所代表的类是否已被加载，解析和初始化过 → ↓ ↓
分配内存（类加载完成后，内存需求确定） ← 加载
↓
根据java堆是否规整（GC⽅法）选择分配⽅法
↙ ↘
指针碰撞 空闲列表
↓
分配内存的并发保证（指针更新的原⼦性）
↙ ↘
CAS+失败重试 按照线程划分在不同的空间中进⾏TLAB -XX:+UseTLAB -XX:-UseTLAB
↓
内存空间初始化为0值，保证对象的实例字段可以不赋初值就可以使⽤。
↓
设置对象头信息（Object Header）：引⽤指针，元数据，hash值，GC分代年龄，锁相关
↓
执⾏对象⽅法

## JVM new
当虚拟机遇到一个 new 指令时（其实就是字节码），首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析和初始化。
因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。
如果发现这个类没有经过上面类加载的过程，那么就执行相应的类加载过程。
类检查完成后，接下来虚拟机将会为新生对象分配内存，对象所需的大小在类加载完成后便可确定（我会在下面的面试题中介绍）。
分配内存相当于是把一块固定的内存块从堆中划分出来。划分出来之后，虚拟机会将分配到的内存空间都初始化为零值，如果使用了 TLAB（本地线程分配缓冲），这一项初始化工作可以提前在 TLAB 分配时进行。这一步操作保证了对象实例字段在 Java 代码中可以不赋值就能直接使用。
接下来，Java 虚拟机还会对对象进行必要的设置，比如确定对象是哪个类的实例、对象的 hashcode、对象的 gc 分代年龄信息。这些信息存放在对象的对象头（Object Header）中。
如果上面的工作都做完后，从虚拟机的角度来说，一个新的对象就创建完毕了；但是对于程序员来说，对象创建才刚刚开始，因为构造函数，即 Class 文件中的 <init>() 方法还没有执行，所有字段都为默认的零值。new 指令之后才会执行 <init>() 方法，然后按照程序员的意愿对对象进行初始化，这样一个对象才可能被完整的构造出来。

## 内存分配方式有哪些
在类加载完成后，虚拟机需要为新生对象分配内存，为对象分配内存相当于是把一块确定的区域从堆中划分出来，这就涉及到一个问题，要划分的堆区是否规整。
假设 Java 堆中内存是规整的，所有使用过的内存放在一边，未使用的内存放在一边，中间放着一个指针，这个指针为分界指示器。那么为新对象分配内存空间就相当于是把指针向空闲的空间挪动对象大小相等的距离，这种内存分配方式叫做指针碰撞(Bump The Pointer)。
如果 Java 堆中的内存并不是规整的，已经被使用的内存和未被使用的内存相互交错在一起，这种情况下就没有办法使用指针碰撞，这里就要使用另外一种记录内存使用的方式：空闲列表(Free List)，空闲列表维护了一个列表，这个列表记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，

### 在 Java 技术体系中，可以作为 GC Roots 进行检索的对象主要有
在虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中类静态属性引用的对象，比如 Java 类的引用类型静态变量。
方法区中常量引用的对象，比如字符串常量池中的引用。
在本地方法栈中 JNI 引用的对象。
JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象比如 NullPointerException、OutOfMemoryError 等，还有系统类加载器。
所有被 synchronized 持有的对象。
还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等。
根据用户所选的垃圾收集器以及当前回收的内存区域的不同，还可能会有一些对象临时加入，共同构成 GC Roots 集合。