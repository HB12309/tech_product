## 垃圾回收算法
标记清除
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。
在标记阶段⾸先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引⽤
的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。
复制算法
从根集合节点进⾏扫描，标记出所有的存活对象，并将这些存活的对象复制到⼀块⼉新的内存（图中下
边的那⼀块⼉内存）上去，之后将原来的那⼀块⼉内存（图中上边的那⼀块⼉内存）全部回收掉
标记整理
复制算法的⾼效性是建⽴在存活对象少、垃圾对象多的前提下的。
这种情况在新⽣代经常发⽣，但是在⽼年代更常⻅的情况是⼤部分对象都是存活对象。如果依然使⽤复
制算法，由于存活的对象较多，复制的成本也将很⾼。
分代收集算法
分代收集算法就是⽬前虚拟机使⽤的回收算法，它解决了标记整理不适⽤于⽼年代的问题，将内存分为
各个年代。⼀般情况下将堆区划分为⽼年代（Tenured Generation）和新⽣代（Young Generation），
在堆区之外还有⼀个代就是永久代（Permanet Generation）。
在不同年代使⽤不同的算法，从⽽使⽤最合适的算法，新⽣代存活率低，可以使⽤复制算法。⽽⽼年代
对象存活率高，没有额外空间对它进⾏分配担保，所以只能使⽤标记清除或者标记整理算法。

## CMS垃圾回收器和G1收集器的特点，和收集过程
CMS收集器是⼀种以获取最短回收停顿时间为⽬标的收集器。基于“标记-清除”算法实现，它的运作过程如下：
初始标记
并发标记
重新标记
并发清除

初始标记、重新标记这两个步骤仍然需要“stop the world”
初始标记仅仅只是标记⼀下GC Roots能直接关联到的对象，速度很快。
并发标记阶段就是进⾏GC Roots Tracing。
重新标记阶段则是为了修正并发标记期间因⽤户程序继续运作⽽导致标记产⽣表动的那⼀部分对象的标记记录，这个
阶段的停顿时间⼀般会⽐初始标记阶段稍⻓点，但远⽐并发标记的时间短。 

CMS是⼀款优秀的收集器，主要优点：并发收集、低停顿。
缺点：
CMS收集器对CPU资源⾮常敏感。在并发阶段，它虽然不会导致⽤户线程停顿，但是会因为占⽤了
⼀部分线程⽽导致应⽤程序变慢，总吞吐量会降低。
CMS收集器⽆法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败⽽导
致Full GC产⽣。
浮动垃圾：由于CMS并发清理阶段⽤户线程还在运⾏着，伴随着程序运⾏⾃然就会有新的垃圾不断产
⽣，这部分垃圾出现的标记过程之后，CMS⽆法在当次收集中处理掉它们，只好留待下⼀次GC中再清
理。这些垃圾就是“浮动垃圾”。
CMS是⼀款“标记--清除”算法实现的收集器，容易出现⼤量空间碎⽚。当空间碎⽚过多，将会给⼤
对象分配带来很⼤的麻烦，往往会出现⽼年代还有很⼤空间剩余，但是⽆法找到⾜够⼤的连续空间
来分配当前对象，不得不提前触发⼀次Full GC。

G1是⼀款⾯向服务端应⽤的垃圾收集器。
G1具备如下特点：
并⾏于并发：G1能充分利⽤CPU、多核环境下的硬件优势，使⽤多个CPU（CPU或者CPU核⼼）
来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执⾏的GC动作，G1收集
器仍然可以通过并发的⽅式让java程序继续执⾏。
分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概
念。它能够采⽤不同的⽅式去处理新创建的对象和已经存活了⼀段时间，熬过多次GC的旧对象以获
取更好的收集效果。
空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；
从局部上来看是基于“复制”算法实现的。
可预测的停顿：这是G1相对于CMS的另⼀个⼤优势，降低停顿时间是G1和ＣＭＳ共同的关注点，
但Ｇ１除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使⽤者明确指定在⼀个⻓度为M
毫秒的时间⽚段内，
G1运作步骤：
1、初始标记；2、并发标记；3、最终标记；4、筛选回收

## 如何判定⼀个对象是否应该回收
为了解决循环引⽤的问题，java中采取了正向可达的⽅式，主要是通过 Roots 对象作为起点进⾏搜索，
搜索⾛过的路径称为“引⽤链”，当⼀个对象到 Roots 没有任何的引⽤链相连时时，证明此对象不可
⽤，当然被判定为不可达的对象不⼀定就会成为可回收对象。
被判定为不可达的对象要成为可回收对象必须⾄少经历两次标记过程，如果在这两次标记过程中仍然没
有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了，能否被回收其实主要还是要
看 finalize() ⽅法有没有与引⽤链上的对象关联，如果在 finalize() ⽅法中有关联则⾃救成功，
对象不可被回收，反之如果没有关联则成功被⼆次标记成功，就可以称为要被回收的垃圾了。

## JVM创建对象的过程 new
常量池中定位类的符号引⽤
↓
检查符号引⽤所代表的类是否已被加载，解析和初始化过 → ↓ ↓
分配内存（类加载完成后，内存需求确定） ← 加载
↓
根据java堆是否规整（GC⽅法）选择分配⽅法
↙ ↘
指针碰撞 空闲列表
↓
分配内存的并发保证（指针更新的原⼦性）
↙ ↘
CAS+失败重试 按照线程划分在不同的空间中进⾏TLAB -XX:+UseTLAB -XX:-UseTLAB
↓
内存空间初始化为0值，保证对象的实例字段可以不赋初值就可以使⽤。
↓
设置对象头信息（Object Header）：引⽤指针，元数据，hash值，GC分代年龄，锁相关
↓
执⾏对象⽅法
