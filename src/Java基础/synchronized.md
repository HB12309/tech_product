synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。**wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。**

看到生成的class文件中的method方法有`ACC_SYNCHRONIZED`标识符，JVM在执行该方法时会隐式的在方法前后加上monitorenter 和 monitorexit，并且根据该方法是实例方法还是静态方法决定锁对象是对象还是类。

CAS就是一种乐观锁，换成大家熟悉的sql语句的话就是
`update obj set  field=new_value where  field=old_value;`

无锁->偏向锁->轻量级锁->重量级锁。这个是错的。无锁到偏向锁我并没有在synchronized源码中找到这个过程，但是不代表无锁不会变成偏向锁，只是这个状态转换的触发并不是因为synchronized

无锁->轻量级锁->重量级锁
        CAS

之所以叫轻量级锁，就是因为它的开销仅仅是CAS，没有什么性能上的消耗，但是它最大的问题是不能碰到线程并发竞争，因为一旦发生了竞争，轻量级锁就会进行膨胀。 就需要引出我们下一位重量级选手——重量级锁出场了。

重入锁的意思是已经获取锁对象的线程，可以再次获取锁对象，但是重入锁有一个规定就是，加锁次数必须等于释放锁的次数，所以轻量级锁第一个挑战就是如何去记录可重入的次数，JVM大叔的设计就是通过再压一个栈帧的方式


锁升级的路线有两条：
1.无锁-》轻量级锁-》重量级锁
2.可偏向-无锁-》可偏向-有锁-》轻量级锁-》重量级锁
具体使用哪一条路，取决于当前锁对象的mw是处于无锁还是可偏向-无锁。
偏向锁和轻量级锁无法应对线程竞争，遇到竞争时就会膨胀成重量级锁，当膨胀成重量级锁之后，需要获取锁对象的线程会先进行自旋尝试，失败的话就会进入Monitor中的队列挂起，等待唤醒。

### 请描述synchronized和Reentranlock的底层实现及重入的底层原理

这个应该是大部分面试官会问的问题了，首先可以先聊聊两者的相同不同之处。相同：
1.都支持可重入。
2.默认都是非公平锁。
3.底层都用到了CAS,链表
不同：
0.Reentranlock是Java实现的，synchronized是关键字由字节码实现。
1.synchronized没有公平锁，而Reentranlock有公平实现。
2.Reentranlock可以创建不同的Condition管理不同情况下的，线程通信。
3.Reentranlock需要显式的释放锁，特别要注意异常情况，synchronized不需要显式的释放锁。
Reentranlock简单的原理

Reentranlock内部使用AQS，而AQS有一个相当重要的state字段，所谓的争抢锁，就是看哪个线程可以把state字段使用CAS的方式，把它从0改到1就视为获取到该锁，而没有获取到锁的线程会进入AQS中的双向链表队列挂起，等待锁释放后的唤醒。
synchronized简单的原理

看了我前面的介绍应该知道synchronized有4种锁：
偏向锁：通过CAS设置当前线程ID至锁对象的mw来获取锁，有线程竞争就会膨胀至重量级锁。
轻量级锁：将mw记录至栈帧中，再使用CAS设置该栈帧指针至锁对象的mw成功便获取锁，有线程竞争会膨胀至重量级锁。
重量级锁：会创建一个Monitor对象并存入mw中，通过CAS设置Monitor对象的onwer字段来获取锁，失败的线程会先进行自旋等待，自旋获取锁失败同样会通过链表的形式进入队列被挂起，等待锁释放后的唤醒。
Reentranlock的重入原理

获得锁的线程通过把state加1即可，释放一次减1，减至0视为完全释放。
synchronized的重入原理

偏向锁 ｜ 轻量级锁：通过压一个栈帧的方式去计数重入锁次数，释放锁便弹出一个栈帧，全部弹出后视为完全释放。
重量级锁：使用一个recursions字段去进行计数，原理和Reentranlock的state一样，不再赘述。

自旋锁本身就是重量级锁的一部分

1.自旋锁是通过自旋（循环）的方式等待在原地去尝试获取锁。
2.题目中的重量级锁，指的操作系统层面的互斥锁，需要线程从用户态切换到内核态，消耗巨大。
解释完以上的内容，答案就显而易见了，因为自旋锁并不一定能获取到锁，而且会占用CPU的资源，如果自旋到最后还是逃避不了被挂起的命运，简直血亏，还不如上来直接就被挂起来的痛快，所以自旋锁适合同步代码块比较短小的时候，如果同步代码块的业务逻辑特别长，那就不应该自旋直接去挂起更好。


3.打开偏向锁是否效率一定会提升？为什么？

答案同上，不一定！如果有看过钻石篇的朋友们，一定知道偏向锁的逻辑简直比轻量级锁和重量级锁加起来都要复杂，而且偏向锁无法应对线程竞争，一旦有竞争就会进行偏向锁撤销，之后再是膨胀流程，如果撤销到一定次数，还会分别进行，批量重偏向，批量锁撤销的流程，再加上这些流程都必须等到safepoint才能进行的（原理就不赘述了），所以导致如果频繁的撤销膨胀会消耗巨大性能，所以不如直接关闭偏向锁-XX:-UseBiasedLocking，直接让他膨胀成重量级锁。甚至可以直接使用-XX:+UseHeavyMonitors，只启用重量级锁。

4种状态是：无锁、偏向锁、轻量级锁、重量级锁。如果再细分的话：无锁(无hash)、无锁(有hash)、偏向锁(无锁)、偏向锁(有锁)、轻量级锁、重量级锁。升级过程我在之前的文章中也反复提到了：
无锁 遇到synchronized 升级成 轻量级锁 遇到线程竞争 升级成 重量级锁。
偏向锁(无锁) 遇到 synchronized 升级成 偏向锁(有锁) 遇到线程竞争 升级成 重量级锁。
如果细分领域的话：
无锁(无hash) 遇到synchronized 升级成 轻量级锁 遇到线程竞争 升级成 重量级锁。
无锁(有hash) 遇到synchronized 升级成 轻量级锁 遇到线程竞争 升级成 重量级锁。
偏向锁(无锁) 遇到 synchronized 升级成 偏向锁(有锁) 遇到需使用hashcode的方法 升级成 重量级锁。原因很简答，因为偏向锁和轻量级锁都没有地方去存放这个临时才决定生成的hashcode，只有重量级锁才能搞定。

synchronized不能继承，需要的话，得自己声明。
