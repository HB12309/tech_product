synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。

Q: Condition 和 AQS 有什么关系？

A: Condition 是基于 AQS 实现的，Condition 的实现类 ConditionObject 是 AQS 的一个内部类，在里面共用了一部分 AQS 的逻辑。

Q: Condition 的实现原理是什么？

A: Condition 内部维护一个条件队列，在获取锁的情况下，线程调用 await，线程会被放置在条件队列中并被阻塞。直到调用 signal、signalAll 唤醒线程，此后线程唤醒，会放入到 AQS 的同步队列，参与争抢锁资源。

Q: Condition 的等待队列和 AQS 的同步队列有什么区别和联系？

A: Condition 的等待队列是单向链表，AQS 的是双向链表。二者之间并没有什么明确的联系。仅仅在节点从阻塞状态被唤醒后，会从等待队列挪到同步队列中。


## 非阻塞的无界线程安全队列 —— ConcurrentLinkedQueue

简单总结就是使用单向链表来保存队列元素，内部使用非阻塞的 CAS 算法，没有加锁。所以计算 size 时可能不准确，同样 size 会遍历链表，所以并不建议使用。

## CopyOnWriteArrayList

Q: 为什么要叫写时复制集合？

A: 因为在 add、remove 操作时会复制出来一个新数组。

Q: CopyOnWriteArrayList 实现原理是什么？



A: 在 add、remove 操作时会进行加锁，然后复制出来一个新数组，操作的都是新数组，而此时原数组是可以提供查询的。当操作结束之后，会将对象指针指向新数组。



Q: CopyOnWriteArrayList 和 ArrayList 有什么区别？



A: CopyOnWriteArrayList 在读多写少的场景下可以提高效率，而 ArrayList 只是普通数组集合，并不适用于并发场景，而如果对 ArrayList 加锁，则会影响一部分性能。


同样对 CopyOnWriteArrayList 而言，仅能保证最终一致性。因为刚写入的数据，是写到的复制的数组中，此时并不能立即查询到。如果要保证实时性可以尝试使用 Collections.synchronizedList 或者加锁等方式。



Q: CopyOnWriteArrayList 复制是怎么进行复制的？

A: 内部使用的是本地方法 System.arraycopy 进行数组的复制。


通过阅读 CopyOnWriteArrayList 源码，了解到写时复制的原理。同时了解到可以使用 System.arraycopy 的方式提高数组复制的效率。

同样 CopyOnWriteArrayList 适合读多写少的场景，满足最终一致性，但是并不能保证数据修改及时查询到。

Q&A

Q: LinkedBlockingQueue 的实现原理？



A: LinkedBlockingQueue 是基于链表实现的，内部使用 ReentrantLock 互斥锁，防止并发放置元素或者取出元素的冲突问题。



take、poll、peek 等从队列中获取元素的操作共用 takeLock 锁。
add、put、offer 等向队列中添加元素的操作共同 putLock 锁。
notEmpty 和 notFull 是 Condition 类型，在 take 和 put 操作时，如果如果队列为空或者队列已满，会调用相应的 await 将线程放入条件队列。


Q: 入队列和出队列方法之间的区别是什么？



A: 



方法	作用
add	添加元素，队列满了，添加失败抛出异常
offer	添加元素， 队列满了，添加失败，返回 false
put	添加元素，队列满了，阻塞等待


poll	弹出元素，队列为空则返回 null
take	弹出元素，队列为空则等待队列中有元素


peek	查看队列中放入最早的一个元素


  结束语



LinkedBlockingQueue 使用和 ArrayBlockingQueue 并没有什么区别，内部实现都是使用的 ReentrantLock，可以对照着阅读。同时 Condition 这块也需要着重了解一下。