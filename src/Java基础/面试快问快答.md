Java语言具有哪些特点？
1. Java为纯面向对象的语言。它能够直接反应现实生活中的对象。
2. 具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它
平台对Java程序进行编译，编译后的程序可在其它平台运行。
3. Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有
很好的可移植性。
4. Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收
器。
5. Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的
指针特性。
6. Java语言提供了对Web应用开发的支持。

面向对象的三大特性？
1. 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且
派生类可以修改或新增新的方法使之更适合特殊的需求。
2. 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的
进行信息隐藏。
3. 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现
行为是不一样的。

字节序定义以及Java属于哪种字节序？
字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方式。
1. 小端:低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。
2. 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。
Java语言的字节序是大端。

JDK与JRE有什么区别？
1. JDK：Java开发工具包（Java Development Kit），提供了Java的开发环境和运行环境。
2. JRE：Java运行环境(Java Runtime Environment)，提供了Java运行所需的环境。
JDK包含了JRE。如果只运行Java程序，安装JRE即可。要编写Java程序需安装JDK.

简述Java访问修饰符
default: 默认访问修饰符，在同一包内可见
private: 在同一类内可见，不能修饰类
protected : 对同一包内的类和所有子类可见，不能修饰类
public: 对所有类可见

构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？
详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变
量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。

接口和抽象类的相同点和区别？
相同点:
1. 都不能被实例化。
2. 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。
不同点：
1. 接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。
2. 实现接口的关键字为implements,继承抽象类的关键字为extends。一个类可以实现多个接口，只能
继承一个抽象类。
3. 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，
希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统
的耦合度，便于日后维护或添加删除方法。

为什么Java语言不支持多重继承？
1. 为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B,
如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。Java语言通过实现
多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接
口B时即使它们都有方法f(),也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义
性。
2. 多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。

Java提供的多态机制？
Java提供了两种用于多态的机制，分别是重载与覆盖。
1. 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定
调用哪个方法。
2. 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向
其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个
对象的方法，即需要到运行期才能确定调用哪个方法。

重载与覆盖的区别？
1. 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。
2. 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。
3. 覆盖要求参数列表相同；重载要求参数列表不同。
4. 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择
方法体。
5. 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。

final、finally和finalize的区别是什么？
1. final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。
2. finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语
句最终一定被执行，经常被用在需要释放资源的情况下。
3. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃
圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时
真正回收对象占用的内存。

出现在Java程序中的finally代码块是否一定会执行？
当遇到下面情况不会执行。
1. 当程序在进入try语句块之前就出现异常时会直接结束。
2. 当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。
其它情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理
后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。值得注意的
是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块
中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。

Java语言中关键字static的作用是什么？
static的主要作用有两个：
1. 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。
2. 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法
或使用类的属性。

具体而言static又可分为4种使用方式：
1. 修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加
载，这个静态变量就会被分配空间，可以使用''类.静态变量''和''对象.静态变量''的方法使用。
2. 修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关
键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。
3. 修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static
代码块只会被执行一次。
4. 修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同
的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。

Java代码块执行顺序
1. 父类静态代码块（只执行一次）
2. 子类静态代码块（只执行一次）
3. 父类构造代码块
4. 父类构造函数
5. 子类构造代码块
6. 子类构造函数
7. 普通代码块
Java中一维数组和二维数组的声明方式？
一维数组的声明方式：
1. type arrayName[]
2. type[] arrayName
二维数组的声明方式：
1. type arrayName[][]
2. type[][] arrayName
3. type[] arrayName[]
其中type为基本数据类型或类，arrayName为数组名字

String和StringBuffer有什么区别？
String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是
可变类，当对象创建后，仍然可以对其值进行修改。

判等运算符==与equals的区别？
== 比较的是引用，equals比较的是内容。
1. 如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象,== 用于比较两
个对象是否指向同一块存储空间。
2. equals是Object类提供的方法之一，每个Java类都继承自Object类，所以每个对象都具有equals这
个方法。Object类中定义的equals方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让
它不是比较引用而是比较数据内容。
为什么要把String设计为不变量？
1. 节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。
2. 提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
3. 安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修
改。

序列化是什么？
序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列
化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该
流读取出来重新构造成一个相同的对象。

简述Java中Class对象
java中对象可以分为实例对象和Class对象，每一个类都有一个Class对象，其包含了与该类有关的信
息。
获取Class对象的方法：
Class.forName(“类的全限定名”)
实例对象.getClass()
类名.class
Java反射机制是什么？
Java反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员
方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得Java具有动态
获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API。
Class类：可获得类属性方法
Field类：获得类的成员变量
Method类：获取类的方法信息
Construct类：获取类的构造方法等信息

简述注解
Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型
的注解实际上可以用于这一目的。
其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代
码，做对应操作。

在探究「注解」的本质之前，我们要先理解一个东西，Annotation 同class和interface一样，也属于一种类型，因此如果想要申明一个注解的话，我们同样需要写一个 java 文件来创建注解。
注解是放在 Java 源码的类、方法、字段、参数前的一种特殊“注释”。


简述元注解
元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：
@Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运
行）。
@Target：表示注解作用的范围。
@Documented：将注解中的元素包含到 Javadoc 中去。
@Inherited：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修
饰，则它的子类也继承了父类的注解。
@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代
表不同的含义。

简述Java异常的分类
Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均
继承Throwable。
Error常见的有StackOverFlowError,OutOfMemoryError等等。
Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也
可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。
简述throw与throws的区别
throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。
throws一般用于方法声明上，代表该方法可能会抛出的异常列表。

简述泛型
泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作
的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛
型方法。

简述泛型擦除
Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为
泛型擦除。

简述Java基本数据类型
byte: 占用1个字节，取值范围-128 ~ 127
short: 占用2个字节，取值范围-215
 ~ 215
-1
int：占用4个字节，取值范围-231
 ~ 231
-1
long：占用8个字节
float：占用4个字节
double：占用8个字节
char: 占用2个字节
boolean：占用大小根据实现虚拟机不同有所差异

简述自动装箱拆箱
对于Java基本数据类型，均对应一个包装类。
装箱就是自动将基本数据类型转换为包装器类型，如int->Integer
拆箱就是自动将包装器类型转换为基本数据类型，如Integer->int

简述重载与重写的区别
重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。
重载即在一个类中，方法名相同，参数类型或数量不同。
简述java的多态
Java多态可以分为编译时多态和运行时多态。
编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。
运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。
运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的
方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父
类的那些同名方法共享一个
方法表项，都被认作是父类的方法。因此可以实现运行时多态。
简述抽象类与接口的区别
抽象类：体现的是is-a的关系，如对于man is a person，就可以将person定义为抽象类。
接口：体现的是can的关系。是作为模板实现的。如设置接口fly，plane类和bird类均可实现该接口。
一个类只能继承一个抽象类，但可以实现多个接口。
简述==与equals方法的区别
对于==，在基本数据类型比较时，比较的是对应的值，对引用数据类型比较时，比较的是其内存的存放
地址。
对于equals方法，在该方法未被重写时，其效果和==一致，但用户可以根据对应需求对判断逻辑进行改
写，比如直接比较对象某个属性值是否相同，相同则返回true，不同则返回false。需保证equals方法相
同对应的对象hashCode也相同。

简述Object类常用方法
1. hashCode：通过对象计算出的散列码。用于map型或equals方法。
需要保证同一个对象多次调用该方法，总返回相同的整型值。
2. equals：判断两个对象是否一致。需保证equals方法相同对应的对象hashCode也相同。
3. toString: 用字符串表示该对象
4. clone:深拷贝一个对象

简述内部类及其作用
成员内部类：作为成员对象的内部类。可以访问private及以上外部类的属性和方法。外部类想要访
问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。
外部类也可访问private修饰的内部类属性。
局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的final变量。
匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量。
静态内部类：类似类的静态成员变量。

简述String/StringBuffer与StringBuilder
String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要
新建对象，将老字符和新增加的字符一并存进去。
StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。
StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。

简述Java序列化与反序列化的实现
序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。
反序列化：将字节序列转化为java对象。
具体实现：实现Serializable接口，或实现Externalizable接口中的writeExternal()与readExternal()方法。
简述JAVA的List
List是一个有序队列，在JAVA中有两种实现方式:
ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，
把原有数组复制到新数组。
LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。
Java中线程安全的基本数据结构有哪些
HashTable: 哈希表的线程安全版，效率低
ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable
Vector：线程安全版Arraylist
Stack：线程安全版栈
BlockingQueue及其子类：线程安全版队列

简述JAVA的Set
Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式：
HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为
PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，
查询O(1)
LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。
TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适
的位置，保证插入后的集合仍然有序。查询O(logn)
简述JAVA的HashMap
JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的
table 数组、元素数量 size、加载因子 loadFactor。
HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的
hash 值一样，就会发生哈希冲突，被放到同一个链表上。
table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链
表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转
化为红黑树。
若当前数据/总数据容量>负载因子，Hashmap将执行扩容操作。
默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1<< 30 、默认加载因子为 0.75。
为何HashMap线程不安全
在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。
虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。
由于HashMap有扩容机制存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。
简述java的TreeMap
TreeMap是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、
删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输
出，红黑树可以按照键的值的大小有序输出。
Collection和Collections有什么区别？
1. Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它
的子类，比如List、Set等。
2. Collections是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供
的排序方法：
Collections.sort(list);提供的反转方法：Collections.reverse(list)。
ArrayList、Vector和LinkedList有什么共同点与区别？
1. ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组。
2. ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空
间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较
低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。
3. Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具
有同步性质。LinkedList也不是线程安全的。
4. LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入
元素的时候不需要对数据进行移动，插入效率较高。
HashMap和Hashtable有什么区别？
1. HashMap是Hashtable的轻量级实现，HashMap允许key和value为null，但最多允许一条记录的key
为null.而HashTable不允许。
2. HashTable中的方法是线程安全的，而HashMap不是。在多线程访问HashMap需要提供额外的同步
机制。
3. Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。
如何决定使用HashMap还是TreeMap?
如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。如果需要对key集
合进行有序的遍历，TreeMap是更好的选择。

fail-fast和fail-safe迭代器的区别是什么？
1. fail-fast直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出
ConcurrentModificationException异常从而导致遍历失败。常见的使用fail-fast方式的容器有
HashMap和ArrayList等。
2. fail-safe这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用fail-safe
方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList。
HashSet中，equals与hashCode之间的关系？
equals和hashCode这两个方法都是从object类中继承过来的,equals主要用于判断对象的内存地址引用
是否是同一个地址；hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet中
存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同：
1. 如果两个对象的hashCode值不同，说明两个对象不相同。
2. 如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equlas方法的返回结果为
true，那么说明两个对象相同，否则不相同。

简述JVM内存模型
线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。
线程共享的运行时数据区:Java 堆、方法区。
简述程序计数器
程序计数器表示当前线程所执行的字节码的行号指示器。
程序计数器不会产生StackOverflowError和OutOfMemoryError。
简述虚拟机栈
Java 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空
间被回收。
栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、
操作栈、动态链接和返回地址等信息。
虚拟机栈会产生两类异常：
StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。
OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。
简述本地方法栈
本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地
方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰
的函数对应的内存模型。
本地方法栈会产生两类异常：
StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。
OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。
简述JVM中的堆
堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆分配内存，堆也是内存管理中最大的一
块。Java的垃圾回收主要就是针对堆这一区域进行。
可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。
堆会抛出 OutOfMemoryError异常。
简述方法区
方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。
JDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移
出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到
元空间。
方法区会抛出 OutOfMemoryError异常。
简述运行时常量池
运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件
中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字
符串基本类型。
JDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。
简述直接内存
直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，
而是由操作系统来管理。
Java通过通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。
简述java创建对象的过程
1. 检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、
解析和初始化，如果没有就先执行类加载。
2. 通过检查通过后虚拟机将为新生对象分配内存。
3. 完成内存分配后虚拟机将成员变量设为零值
4. 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。
5. 执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址
赋值给引用变量。
简述JVM给对象分配内存的策略
1. 指针碰撞： 这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另
一边，通过指针挪动完成分配。
2. 空闲列表： 对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配
时从列表中找到一块足够大的空间划分给对象并更新列表记录。
java对象内存分配是如何保证线程安全的
1. 对分配内存空间采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。
2. 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私 有"内存中分配。一般采用这种策略。
简述对象的内存布局
对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。
对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC
分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。
类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数
据，
实例数据存储代码中所定义的各种类型的字段信息。
对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。
如何判断对象是否是垃圾
引用计数法：设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被
标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。
可达性分析：通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果
某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用
的对象、类静态属性引用的对象、常量引用的对象。
简述java的引用类型
强引用： 被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。
软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建
软引用。
弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用
WeakReference 类来创建弱引用。
虚引用： 无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必
须与引用队列联合使用。
简述标记清除算法、标记整理算法和标记复制算法
标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。
标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存
标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用
完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。
简述分代收集算法
根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
一般将堆分为新生代和老年代，对这两块采用不同的算法。
新生代使用：标记复制算法
老年代使用：标记清除或者标记整理算法
简述Serial垃圾收集器
单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用
标记整理算法。简单高效。
简述ParNew垃圾收集器
可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。
简述Parallel Scavenge垃圾收集器
注重吞吐量，即cpu运行代码时间/cpu耗时总时间（cpu运行代码时间+ 垃圾回收时间）。新生代使用标
记复制算法，老年代使用标记整理算法。
简述CMS垃圾收集器
注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采
用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步
骤。
初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。并发标记：可达性分析过
程(程序不会停顿)。
并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the
world）扫描CMS堆中剩余对象。
并发清除：清理垃圾对象，(程序不会停顿)。
并发重置，重置CMS收集器的数据结构。
简述G1垃圾收集器
和之前收集器不同，该垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不
再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个
小空间可以单独进行垃圾回收。
初始标记：标记与GC roots直接关联的对象。
并发标记：可达性分析。
最终标记，对并发标记过程中，用户线程修改的对象再次标记一下。
筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计
划并回收。
简述Minor GC
Minor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一
般回收速度也比较快。
简述Full GC
Full GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失
败，永生代空间不足会产生full gc。
常见内存分配策略
大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。
大对象需要大量连续内存空间，直接进入老年代区分配。
如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄
设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年
代。
如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可
以直接进入老年代。
空间分配担保。MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果
满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保
失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满
足将Minor GC，否则改成一次 FullGC。

简述JVM类加载过程
加载：
1. 通过全类名获取类的二进制字节流. 
2. 将类的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成类的Class对象，作为方法区数据的入口。
验证：对文件格式，元数据，字节码，符号引用等验证正确性。
准备：在方法区内为类变量分配内存并设置为0值。
解析：将符号引用转化为直接引用。
初始化：执行类构造器clinit方法，真正初始化。
简述JVM中的类加载器
BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。C++编写。
ExtensionClassLoader扩展类加载器： /lib/ext目录下的jar包和类。java编写。
AppClassLoader应用类加载器，加载当前classPath下的jar包和类。java编写。
简述双亲委派机制
一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果
没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法
完成时才尝试自己加载。
加载类顺序：BootstrapClassLoader->ExtensionClassLoader->AppClassLoader->CustomClassLoader
检查类是否加载顺序：
CustomClassLoader->AppClassLoader->ExtensionClassLoader->BootstrapClassLoader
双亲委派机制的优点
1. 避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了java程序的
稳定运行。
2. 保证核心API不被修改。
如何破坏双亲委派机制
重载loadClass()方法，即自定义类加载器。
如何构建自定义类加载器
1. 新建自定义类继承自java.lang.ClassLoader
2. 重写findClass、loadClass、defineClass方法
JVM常见调优参数
-Xms 初始堆大小
-Xmx 最大堆大小
-XX:NewSize 年轻代大小
-XX:MaxNewSize 年轻代最大值
-XX:PermSize 永生代初始值
-XX:MaxPermSize 永生代最大值
-XX:NewRatio 新生代与老年代的比例