> https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962839&idx=1&sn=408a063cf75893b9169879fb57d4ac8d&chksm=bd2d080b8a5a811d397555f56377407e148c89f004ac44d5d274bb8f720bb0664cdbf69ffd4a&scene=21#wechat_redirect

如果我们想对学生表（t_student）加表锁，可以使用下面的命令：
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent wirte;
需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。
要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：
unlock tables
另外，当会话退出后，也会释放所有表锁。
不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。

表锁有什么好处？
（1）表锁占用内存少很多，行锁的数量与行记录数相关，非常耗内存；
（2）如果业务经常读写表中很大一部分数据时，表锁会更快，因为此时只涉及一个锁，而不是同时管理N多个锁；
（3）如果业务经常使用group by，表锁会更快，原因同（2）；

虽然MyISAM只支持表锁，但高并发select与insert的业务场景，上述机制使得MyISAM的表锁依然有非常强劲的性能。
为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？

MyISAM的索引与记录存储分离，有单独的区域存储行记录，PK是非聚集索引。
MyISAM表，如果数据文件(data file)紧密存储，中间没有空闲块(free blocks)，数据总是插入到数据文件的尾部(end)，就如同追加日志一样，性能很高，此时的并发insert与select是不加锁的(lock free)
如上图所示：
（1）数据文件连续且紧密的存储着；
（2）并发insert无表锁争抢（只需插入队列互斥）；
（3）insert只在数据文件的尾部进行；
（4）并发select也能够同时进行（共享读锁）；
 
知识点三：
MyISAM表，如果数据文件(data file)中间有空洞(hole)，上述机制会失效，直到空洞被新数据填满，又会启用不加锁机制。
 
空洞是怎么导致的？
删除或者修改数据，都可能导致空洞。