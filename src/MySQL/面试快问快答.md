## 有一定深度的MySQL

主要是 Buffer pool 还有数据页的逻辑，逻辑图、脑图很重要，画清楚了就ok了

> 公众号：赐我白日梦

简述数据库三大范式

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满
足了第一范式。
数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二
范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名
称）中，学号->姓名，而专业编号->专业名称，不满足数据库第二范式
数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个
属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性
别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范
式。

简述MySQL的架构
MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。
应用层：负责和客户端，响应客户端请求，建立连接，返回数据。
逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。
数据库引擎层：有常见的MyISAM,InnoDB等等。
物理层：负责文件存储，日志等等。

简述执行SQL语言的过程
1. 客户端首先通过连接器进行身份认证和权限相关
2. 如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。
3. 没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。
4. 通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。
5. 执行语句，并从存储引擎返回数据。

简述MySQL的共享锁shared、排它锁 exclued
共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。
排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读
取正在写入的同一资源。

简述MySQL中的按粒度的锁分类
表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。
行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会
创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但
加锁的开销也最大，加锁慢，会出现死锁。
Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出
现幻读的情况。
Next-key Lock： 行锁+gap锁。

如何解决数据库死锁
1. 预先检测到死锁的循环依赖，并立即返回一个错误。
2. 当查询的时间达到锁等待超时的设定后放弃锁请求。

简述乐观锁和悲观锁
乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的
时候才通过一种机制来验证数据是否存在冲突。
悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它
释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据
进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。

简述InnoDB存储引擎
InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，
支持外键，适合数据增删改查都频繁的情况。
InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE
READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间
隙进行锁定防止幻行的插入。

简述MyISAM存储引擎
MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级
锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改
要求高的情况

简述Memory存储引擎
Memory存储引擎将所有数据都保存在内存，不需要磁盘 IO。支持哈希索引，因此查找速度极快。
Memory 表使用表级锁，因此并发写入的性能较低。

索引是什么？
索引是存储引擎中用于快速找到记录的一种数据结构。在关系型数据库中，索引具体是一种对数据库中
一列或多列的值进行排序的存储结构。
为什么引入索引？
为了提高数据查询的效率。索引对数据库查询良好的性能非常关键，当表中数据量越来越大，索引对性
能的影响越重要。

MySQL索引类型mysql里目前只支持4种索引分别是：full-text，b-tree，hash，r-tree
b-tree索引应该是mysql里最广泛的索引的了，除了archive基本所有的存储引擎都支持它

myisam支持全文检索。r tree是存地图的

Mysql有哪些常见索引类型？
数据结构角度
B-Tree索引
哈希索引
R-Tree索引
全文索引
物理存储角度
主键索引（聚簇索引）：叶子节点存的是整行的数据
非主键索引（二级索引）：叶子节点存的主键的值

简述B-Tree与B+树
B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字
值，且右子节点的关键字值大于或等于该节点关键字值。
B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶
子节点增加了一个链指针，方便进行范围查询。
B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数
据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。
B树每一个节点都包含key和value，查询效率比B+树高。

简述Hash索引
哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向
每个数据行的指针。只有 Memory 引擎显式支持哈希索引。
Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。
简述自适应Hash索引
InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称
为自适应Hash索引。

简述聚集索引和稀疏索引
聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过
双向链表连接。表数据访问更快，但表更新代价高。
稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺
序搜索，直到找到所需的数据为止。

简述辅助索引与回表查询
辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找
到与索引相对应的行数据。
通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查
询。

简述联合索引和最左匹配原则
联合索引是指对表上的多个列的关键词进行索引。
对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到
遇到范围查询（>,<,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字
段基础上，再对第二个字段排序。

简述覆盖索引
覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的
值。
为什么数据库不用红黑树用B+树
红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，IO次
数很多，导致会比较慢，因此检索的次数也就更多。
B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO次数较少，检索效率会更高。
基于主键索引的查询和非主键索引的查询有什么区别？
对于select * from 主键=XX，基于主键的普通查询仅查找主键这棵树，对于select * from 非主键=XX，
基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表），因为非主键索引叶子
节点仅存主键值，无整行全部信息。
非主键索引的查询一定会回表吗？
不一定，当查询语句的要求字段全部命中索引，不用回表查询。如select 主键 from 非主键=XX，此时非
主键索引叶子节点即可拿到主键信息，不用回表。

简述MySQL优化流程
1. 通过慢日志定位执行较慢的SQL语句
2. 利用explain对这些关键字段进行分析
3. 根据分析结果进行优化

简述MySQL中的日志log
redo log: 存储引擎级别的log（InnoDB有，MyISAM没有），该log关注于事务的恢复.在重启mysql服务
的时候，根据redo log进行重做，从而使事务有持久性。
undo log：是存储引擎级别的log（InnoDB有，MyISAM没有）保证数据的原子性，该log保存了事务发
生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一。
bin log：数据库级别的log，关注恢复数据库的数据。

简述事务
事务内的语句要么全部执行成功，要么全部执行失败。
事务满足如下几个特性：
原子性（Atomicity）:
一个事务中的所有操作要么全部完成，要么全部不完成。
一致性（Consistency）:
事务执行前后数据库的状态保存一致。
隔离性（Isolation）
多个并发事务对数据库进行操作，事务间互不干扰。
持久性（Durability）
事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失

数据库中多个事务同时进行可能会出现什么问题？
丢失修改
脏读：当前事务可以查看到别的事务未提交的数据。
不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了。
幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些
原先存在的数据。

SQL的事务隔离级别有哪些？
读未提交：
一个事务还没提交，它做的变更就能被别的事务看到。
读提交：
一个事务提交后，它做的变更才能被别的事务看到。
可重复读：
一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未
提交，做出的变更其它事务也看不到。
串行化：
对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行
的事务完成才能继续执行。

什么是MVCC？
MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前
提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔
离性,在事务隔离级别为读提交和可重复读中使用到。
在InnoDB中，事务在开始前会向事务系统申请一个事务ID，该ID是按申请顺序严格递增的。每行数据具
有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构
中包含多个信息字段。其中实现MVCC的主要涉及最近更改该行数据的事务ID（DB_TRX_ID）和可以
找到历史数据版本的指针（DB_ROLL_PTR）。InnoDB在每个事务开启瞬间会为其构造一个记录当前
已经开启但未提交的事务ID的视图数组。通过比较链表中的事务ID与该行数据的值与对应的
DB_TRX_ID，并通过DB_ROLL_PTR找到历史数据的值以及对应的DB_TRX_ID来决定当前版本的数据
是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性。
读提交和可重复读都基于MVCC实现，有什么区别？
在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每
个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而
对于读提交，查询能看到每个语句启动前已经提交的数据。

InnoDB如何保证事务的原子性、持久性和一致性？
利用undo log保障原子性。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务
原子性。
利用redo log保证事务的持久性，该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行
重做，从而使事务有持久性。
利用undo log+redo log保障一致性。事务中的执行需要redo log，如果执行失败，需要undo log 回滚。

MySQL是如何保证主备一致的？
MySQL通过binlog（二进制日志）实现主备一致。binlog记录了所有修改了数据库或可能修改数据库的
语句，而不会记录select、show这种不会修改数据库的语句。在备份的过程中，主库A会有一个专门的
线程将主库A的binlog发送给备库B进行备份。其中binlog有三种记录格式：
1. statement:记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。优点是binlog日
志量少，IO压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环
境不同可能导致主备不一致。
2. row:记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数
据，会把涉及的每行数据都记录到binlog。优点是能够完全的还原或者复制日志被记录时的操作。
缺点是日志量占用空间较大，IO压力大，性能消耗较大。
3. mixed:混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函
数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有
可能，就用row格式，
否则就用statement格式。但是在生产环境中，一般会使用row模式。

redo log与binlog的区别？
1. redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现
的，会记录所有引擎对数据库的修改。
2. redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这
个语句的原始逻辑。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切
换到下一个，并不会覆盖以前的日志。


crash-safe能力是什么？
InnoDB通过redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash￾safe。 WAL技术是什么？
WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前，
会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I/O访问，涉及磁盘随机I/O访问是非常消耗
时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。

两阶段提交是什么？
为了保证binlog和redo log两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶
段提交的机制。
1. 执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录redo log中，此时
redo log处于prepare状态。
2. 存储引擎告知执行器执行完毕，执行器生成这个操作对应的binlog，并把binlog写入磁盘。
3. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交commit状态，更新完成。

只靠binlog可以支持数据库崩溃恢复吗？
不可以。
历史原因：
1. InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持
的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那引入InnoDB原有的
redo log来保证崩溃恢复能力。
实现原因：
2. binlog没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog记录着数据行的增删改，
但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时，
其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，
甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo
log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些
正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为
是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过
程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中。
3. 操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page
cache，并没有把数据持久化到磁盘,fsync才是将数据持久化到磁盘的操作。通过参数设置
sync_binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交
的事务以及binlog日志由于没有持久化而丢失。

简述MySQL主从复制
MySQL提供主从复制功能，可以方便的实现数据的多处自动备份，不仅能增加数据库的安全性，还能进
行读写分离，提升数据库负载性能。
主从复制流程：
1. 在事务完成之前，主库在binlog上记录这些改变，完成binlog写入过程后，主库通知存储引擎提交事
物2. 从库将主库的binlog复制到对应的中继日志，即开辟一个I/O工作线程，I/O线程在主库上打开一个普
通的连接，然后开始binlog dump process，将这些事件写入中继日志。从主库的binlog中读取事
件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。
读写分离：即只在MySQL主库上写，只在MySQL从库上读，以减少数据库压力，提高性能。

select也是开事务的，mysql的增删改查都是开事务的，只不过平时我们都是auto commit的
平常用事务，是为了保证你的一系列操作是执行还是不执行。而单条ud的操作。等同于事务
单条的更改也算是一条事务，只不过这个事务里只有一条，mysql对这种单条的事务和多条sql的事务底层处理是一样的吗
看具体使用的存储引擎，InnoDB支持事务。2.数据库连接时，有auto_commit参数。你可以看下这个参数的左右

### 锁、事务等因什么而存在？

为了保证数据库的数据准确性，1、在多个会话里CRUD数据的准确性。2、在机器或者进程挂掉的时候，数据的完整性。等等。

因为操作了同一块的资源，有并发了，才需要锁，读锁写锁，保证同一时刻对于资源操作的准确性。没有并发就没有锁。

为了保证数据库的可用，在innodb下，使用了各种各样的锁和MVCC，优化、效率，事务这个含义在数据库都有，并不是MySQL专有。为了数据完整，ACID等特性，redo log undo log binlog，各种都来。

事务本身是为了需求而出现的，我们有这样的需求，所以有事务的出现，如何保证事务呢？

## 基数

基数指的就是MySQL表中某一列的不同值的数量。
如果这一列是唯一索引，那基数 == 行数。
如果这一列是sex，枚举类型只有男女，那它是基数就是2。
Cardinality越高，列就越有成为索引的价值。MySQL执行计划也会基于Cardinality选择索引。
通过下面的方式可以看到表中各列的基数。

基数的维护，更新，持久化，计算，估算。

## sql_mode 
SQL的执行模式。
默认情况下MySQL会用严格模式运行SQL。
你可以像下面这样查看MySQL使用了哪些sql mode。

从上面的实验来看，相信你已经看出了现象：无论是否开启了严格模式，MySQL都不允许往not null字段插入null值，它不会因为你插入null，而将null转成该数据类型的0值。
严格模式，就是将参数 NO_AUTO_CREATE_USER 设置给sql mode

### date、datetime、time、timestamp、year 有什么区别

Datetime比Date更精确。最常用的就是 datetime
date: 之前用的
time:
year: 就是年份啊
timestamp: 2038年咋弄？

### 查询缓存和BufferPool

当一个SQL打向MySQL Server之后，MySQL Server首选会从查询缓存中查看是否曾经执行过这个SQL，如果曾经执行过的话，之前执行的查询结果会以Key-Value的形式保存在查询缓存中。key是SQL语句，value是查询结果。我们将这个过程称为查询缓存，我们disabled，8.0后也没有了

连接池也好、缓存池也好，只要是XXX池，都是为加速而设计的。比如操作系统的文件系统为了加快数据的读取速度，每次都做低效率的磁盘随机IO设计了缓冲写机制。而Buffer Pool就是MySQL存储引擎为了加速数据的读取速度而设计的缓冲机制。

Buffer Pool中的描述信息以双向链表（LRU）的形式组织在一起。通过数据页的描述信息，我们能找它所描述的缓存页的位置。
看到这里你除了要知道查询缓存和Buffer Pool的所属：前者属于MySQLServer层面，后者属于存储引擎层面。还需要知道另一个知识点：相对于极容易整体失效的查询缓存来说，Buffer Pool是通过InnoDB优化后的LRU算法控制将老化的数据数据从缓存中干掉的，所以Buffer Pool中缓存的数据不会像前者一样一次性整体失效。

MySQL 在查询数据时，对于 InnoDB 存储引擎而言，会先将磁盘上的数据以页为单位，先将数据页加载进内存，然后以缓存页的形式存放在「Buffer Pool」中。Buffer Pool 是 InnoDB 的一块内存缓冲区，在 MySQL 启动时，会按照配置的缓存页的大小，将 Buffer Pool 缓存区初始化为许多个缓存页，默认情况下，缓存页大小为 16KB

## LRU-List 优化

传统的缺点：因为 MySQL预读机制 的存在
当Buffer Pool中存储着一个区中13个连续的数据页时，你再去这个区里面读取，MySQL就会将这个区里面所有的数据页都加载进Buffer Pool中的LRU链表中。（然后可能你根本不会使用这些被预读的数据页）

导致：当你执行select * from xxx;时，如果表中的数据页非常多，那这些数据页就会一一将Buffer Pool中的经常使用的缓存页挤下去，可能导致留在LRU链表中的全部是你不经常使用的数据。

LRU链表被MidPoint分成了New Sublist和Old Sublist两部分。
其中New Sublist大概占比5/8，Old Sublist占比3/8。
New Sublist存储着young page，而Old Sublist存储着Old Page。
这其实是一种冷热数据分离设计思想。他相对于传统的LRU链表有很大的优势。

注：有点类似于JVM分代GC的思想。

### Free List
MySQL启动后Buffer Pool会初始化。Buffer Pool也会初始化好N多个空白的缓存页，以及它们的描述数据会被组织成LRU链表以及FreeList 双向链表。

这时你从磁盘中读取一个数据页，会先从Free List中找出一个空闲缓存页的描述信息，然后将你读出的数据页中加载进缓存页中。同时将缓存页的描述信息从Free List中剔除，此外该描述信息块还会被维护进LRU链表中。

数据页被加载进Buffer Pool后你就可以对其进行变更操作了。

Buffer Pool、LRU List、Flush List、Free List 相辅相成，建议放在一起串讲。

MySQL对数据的增删改查都是内存中完成的，这块内存就是Buffer Pool。

FlushList中的节点存放就是被修改了脏数据页的描述信息块。
随着MySQL被使用的时间越来越长，BufferPool的大小就越来越小。等它不够用的时候，就会将部分LRU中的数据页描述信息移除出去，这时如果发现被移除出来的数据页在FLushList中，就会触发fsync的操作，触发随机写磁盘。如果该数据页是干净的，那移除出去就好了。其他也不用干啥。

### 表空间
表空间会对应着磁盘上的物理文件，MySQL有很多种表空间
sys 表空间、file per table 表空间、临时表空间、undo 表空间

### 数据行吗？行溢出机制

### 主从复制

MySQL的Gtid复制原理是什么？

mysql主从复制原理就是主库创建一个专门用于给从库拉取binlog的账号，并且给这个账号授权，让他可以拉取哪个DB的那个表的binlog，具体的授权SQL是：
```
grant repliacation slave on xx.xx to username@ip identify by 'password'
```
这样从库就能登陆主库拉取binlog，那拉取binlog就得知道从哪个binlog的哪个位点拉取，现有的有两个方案：fileName + position 还有就是通过gtid自动找点。

同步：
主库写redolog 事物处于prepare状态、主库写binlog，然后从库拉取binlog去回放，从库回放成功后返回给主库ack确认，所有的从库都完成回放后主库提交事物。这样是可以保证主从数据一致的但是缺点就是速度太慢了。
半同步：
主库写redolog 事物处于prepare状态、主库写binlog，然后从库拉取binlog后返回给主库ack，在众多从库中只要收到一个ack主库就提交事物
异步复制：
主库根本不管从库有没有拉取回放binlog，直接写redo、binlog、然后提交事物
首先不允许出现主从数据不一致的情况：如果主从不一致对业务来说是有损的，一旦发生主从数据不一致的情况，从库就会出现断开连接的可能。

### slow query

通常出现慢查到情况如下：
1、表中的数据量很大，而且SQL的执行没有走索引
2、数据量太大了，即使走了索引依然超过了阈值
3、大量的慢查占据MySQL连接，导致正常的SQL得不到连接执行从而变成慢查SQL
4、优化器选错了索引

## 索引失效
对查询进⾏优化，要尽量避免全表扫描，⾸先应考虑在 where 及 order by 涉及的列上建⽴索引。
应尽量避免在 where ⼦句中对字段进⾏ null 值判断，否则将导致引擎放弃使⽤索引⽽进⾏全表扫描
应尽量避免在 where ⼦句中使⽤ != 或 <> 操作符，否则将引擎放弃使⽤索引⽽进⾏全表扫描。
应尽量避免在 where ⼦句中使⽤ or 来连接条件，如果⼀个字段有索引，⼀个字段没有索引，将导
致引擎放弃使⽤索引⽽进⾏全表扫描
in 和 not in 也要慎⽤，否则会导致全表扫描
like模糊全匹配也将导致全表扫描