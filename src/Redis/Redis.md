redis中是redis-server和redis-cli分别对应服务端和客户端。 服务端一般启动后，会等待客户端的连接及连接后发送过来的命令，而且服务端和客户端通常都不会在同一台计算机上，就会涉及到网络通信，那么服务端和客户端是怎么通信的？这就会涉及另一个重要的概念就是协议。常见的协议有TCP,HTTP等，这里我不会展开（因为我压根也不懂啊），而redis中的协议就是RESP（REdis Serialization Protocol）。关于协议我之后在展开，这里可以把协议理解为由作者自己定义的一种约定，客户端和服务端都按照这样的约定去处理(解码或编码)发送和接收到的消息。

把黄线后的RESP整个取出来就是并通过查询ASCII转换为

RESP全称Redis Serialization Protocol，是一种文本协议。
协议：RESP3 RESP2 RESP1 等等，随着 redis version 的提升，协议版本也在提升，并做一些向下兼容

服务端的启动本质上就是对redisServer对象的初始化
1.db数组，默认长度16，任何客户端连接默认为第0号db，内部用一个字典存储了所有的数据
2.clients队列，记录着当前活跃的客户端
3.命令字典，记录着当前服务端支持的所有命令对应的命令对象
4.会启动3个后台线程分别来处理：关闭文件，AOF同步， 清理内存

通过一个最简单的set和get的小例子，过了一遍客户端和服务端的交互
1.客户端连接至服务端时会先创建connection对象和client对象，并把client对象加入clients队列中，由connection对象处理所有该客户端发来的请求
2.当client发来请求时，connection会先解析协议，并将该请求转给对应的命令处理函数来处理
3.处理完毕后会再封装成协议返回给客户端
4.当客户端退出时，服务端会先将它放入clients_to_close队列，通过事件的before钩子函数来对该队列中等待退出的客户端做清理

## String
1.sds是redis中非常基础的数据结构，很多地方都会用到。
2.sds被设计成了5种结构体以应对不同长度字符串的存储，目的是为了尽可能的节省内存的使用，特别是sds5用一个字节就存储了字符串的长度和sds类型，非常巧妙。
3.比较重要的方法就是创建和扩容，掌握了原理再去阅读其他的方法就会变得非常容易。扩容和缩容

如果你对HashMap中的原理比较清楚的话，redis的字典除了rehash不太一样，其他的增删改查基本上的流程是一致的。

## Hash
1.dict是redis中非常重要的数据结构，也是查询高性能的秘诀之一，很多地方都会用到。
2.dict底层由数组加链表组成，通过对key进行散列求到了hash值对应到数组索引，就可以将该键值的元素存放到该索引下，如果遇到了hash冲突，则通过单向链表的形式将多个元素关联起来。
3.dict底层通过2个数组来实现渐进式rehash，在字典不需要扩容时，默认只会使用到一号数组，待需要扩容时则会初始化二号数组，之后添加的元素都会挂载到二号数组上，并通过字典的其他操作进行单步的rehash，渐渐的将一号数组中的元素迁移至二号数组，待迁移完毕后，二号数组上位成为新的一号数组。

渐进式rehash，增删改查的时候 rehashIndex记录当前进到哪里了。查询的时候也要 rehash，所以有一段时间，状态都是 rehash状态。


redis这样设计巧妙的把每次rehash的操作平摊到了对该字典的一次操作上，这样带来的性能损失非常小，而且还因为两个数组可以在不影响使用的前提下对字典就行键值对的迁移。

## 双向链表
如果你有学习过Java中的LinkedList，我只能说几乎就是一样的，只是换成了c来实现。双向链表在redis中的应用也同样广泛，比如在服务端初始化的时候，可以看到redisServer有很多字段都是这个数据结构的。
1.list也是redis中非常重要的数据结构，很多地方都会用到。
2.list的源码写的非常通俗易懂，如果阅读过Java中的LinkedList，再来看这里的源码几乎就是秒懂，就是最基本的双向链表的实现。

```
string == Map<String，String>
map    == Map<String，Map<String>>
list   == Map<String ， List<String>>
set    == Map<String，Set<String>>
zset   == Map<String，ZSet<String>>
```